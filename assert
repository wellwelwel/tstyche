"use strict";
// Patch
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAssert = exports.processAssert = void 0;
const node_assert_1 = require("assert");
const node_process_1 = require("process");
const node_path_1 = __importDefault(require("path"));
const find_file_from_stack_js_1 = require("../parsers/find-file-from-stack.js");
const assert_js_1 = require("../parsers/assert.js");
const get_runtime_js_1 = require("../parsers/get-runtime.js");
const indentation_js_1 = require("../configs/indentation.js");
const format_js_1 = require("./format.js");
const write_js_1 = require("./write.js");
const cwd = (0, node_process_1.cwd)();
const regexFile = /file:(\/\/)?/;
const processAssert = async (cb, options) => {
  const isPoku =
    typeof (node_process_1.env === null || node_process_1.env === void 0 ? void 0 : node_process_1.env.FILE) ===
      "string" &&
    (node_process_1.env === null || node_process_1.env === void 0 ? void 0 : node_process_1.env.FILE.length) > 0;
  const FILE = node_process_1.env.FILE;
  let preIdentation = "";
  if (indentation_js_1.indentation.hasDescribe) {
    preIdentation += "  ";
  }
  if (indentation_js_1.indentation.hasItOrTest) {
    preIdentation += "  ";
  }
  try {
    const cbResult = cb();
    if (cbResult instanceof Promise) {
      await cbResult;
    }
    if (typeof options.message === "string") {
      const message =
        isPoku && !indentation_js_1.indentation.hasDescribe && !indentation_js_1.indentation.hasItOrTest
          ? `${preIdentation}${(0, format_js_1.format)(
              `${(0, format_js_1.format)(`✔ ${options.message}`).bold()} ${(0, format_js_1.format)(`› ${FILE}`)
                .success()
                .dim()}`
            ).success()}`
          : `${preIdentation}${(0, format_js_1.format)(`✔ ${options.message}`).success().bold()}`;
      write_js_1.Write.log(message);
    }
  } catch (error) {
    if (error instanceof node_assert_1.AssertionError) {
      const { code, actual, expected, operator } = error;
      const absolutePath = (0, find_file_from_stack_js_1.findFile)(error).replace(regexFile, "");
      const file = node_path_1.default.relative(node_path_1.default.resolve(cwd), absolutePath);
      let message = "";
      if (typeof options.message === "string") {
        message = options.message;
      } else if (options.message instanceof Error) {
        message = options.message.message;
      } else if (typeof options.defaultMessage === "string") {
        message = options.defaultMessage;
      }
      const finalMessage =
        (message === null || message === void 0 ? void 0 : message.trim().length) > 0
          ? (0, format_js_1.format)(`✘ ${message}`).fail().bold()
          : (0, format_js_1.format)("✘ Assertion Error").fail().bold();
      write_js_1.Write.log(
        isPoku
          ? `${preIdentation}${finalMessage} ${(0, format_js_1.format)(`› ${FILE}`).fail().dim()}`
          : `${preIdentation}${finalMessage}`
      );
      file && write_js_1.Write.log(`${(0, format_js_1.format)(`${preIdentation}      File`).dim()} ${file}`);
      write_js_1.Write.log(`${(0, format_js_1.format)(`${preIdentation}      Code`).dim()} ${code}`);
      write_js_1.Write.log(`${(0, format_js_1.format)(`${preIdentation}  Operator`).dim()} ${operator}\n`);
      if (!(options === null || options === void 0 ? void 0 : options.hideDiff)) {
        const splitActual = (0, assert_js_1.parseResultType)(actual).split("\n");
        const splitExpected = (0, assert_js_1.parseResultType)(expected).split("\n");
        const diffLines = [];
        for (let i = 0; i < splitActual.length; i++) {
          if (splitActual[i] !== splitExpected[i]) {
            diffLines.push(`${preIdentation}  ${(0, format_js_1.format)(splitActual[i]).fail().bold()}`);
            diffLines.push(`${preIdentation}  ${(0, format_js_1.format)(splitExpected[i]).success().bold()}`);
          }
        }
        write_js_1.Write.log(
          (0, format_js_1.format)(
            `${preIdentation}  ${(options === null || options === void 0 ? void 0 : options.actual) || "Actual"}:`
          ).dim()
        );

        write_js_1.Write.log(diffLines.join("\n"));
      }
      if (options.throw) {
        console.error(error);
        write_js_1.Write.hr();
      }
      (0, node_process_1.exit)(1);
    }

    throw error;
  }
};
exports.processAssert = processAssert;
const createAssert = (nodeAssert) => {
  const ok = (value, message) => {
    (0, exports.processAssert)(
      () => {
        nodeAssert.ok(value);
      },
      { message }
    );
  };
  const equal = (actual, expected, message) => {
    (0, exports.processAssert)(
      () => {
        nodeAssert.equal(actual, expected);
      },
      { message }
    );
  };
  const deepEqual = (actual, expected, message) => {
    (0, exports.processAssert)(() => nodeAssert.deepEqual(actual, expected), { message });
  };
  const strictEqual = (actual, expected, message) => {
    (0, exports.processAssert)(() => nodeAssert.strictEqual(actual, expected), { message });
  };
  const deepStrictEqual = (actual, expected, message) => {
    (0, exports.processAssert)(() => nodeAssert.deepStrictEqual(actual, expected), {
      message,
    });
  };
  const notEqual = (actual, expected, message) => {
    (0, exports.processAssert)(() => nodeAssert.notEqual(actual, expected), {
      message,
    });
  };
  const notDeepEqual = (actual, expected, message) => {
    (0, exports.processAssert)(() => nodeAssert.notDeepEqual(actual, expected), { message });
  };
  const notStrictEqual = (actual, expected, message) => {
    (0, exports.processAssert)(() => nodeAssert.notStrictEqual(actual, expected), {
      message,
    });
  };
  const notDeepStrictEqual = (actual, expected, message) => {
    (0, exports.processAssert)(() => nodeAssert.notDeepStrictEqual(actual, expected), {
      message,
    });
  };
  const ifError = (value, message) => {
    (0, exports.processAssert)(
      () => {
        nodeAssert.ifError(value);
      },
      {
        message,
        defaultMessage: "Expected no error, but received an error",
        hideDiff: true,
        throw: true,
      }
    );
  };
  const fail = (message) => {
    (0, exports.processAssert)(
      () => {
        nodeAssert.fail(message);
      },
      {
        message,
        defaultMessage: "Test failed intentionally",
        hideDiff: true,
      }
    );
    process.exit(1);
  };
  function doesNotThrow(block, errorOrMessage, message) {
    (0, exports.processAssert)(
      () => {
        if (
          typeof errorOrMessage === "function" ||
          errorOrMessage instanceof RegExp ||
          typeof errorOrMessage === "object"
        ) {
          nodeAssert.doesNotThrow(block, errorOrMessage, message);
        } else {
          const msg = typeof errorOrMessage === "string" ? errorOrMessage : message;
          nodeAssert.doesNotThrow(block, msg);
        }
      },
      {
        message: typeof errorOrMessage === "string" ? errorOrMessage : message,
        defaultMessage: "Expected function not to throw",
        hideDiff: true,
        throw: true,
      }
    );
  }
  function throws(block, errorOrMessage, message) {
    if (
      typeof errorOrMessage === "function" ||
      errorOrMessage instanceof RegExp ||
      typeof errorOrMessage === "object"
    ) {
      (0, exports.processAssert)(() => nodeAssert.throws(block, errorOrMessage), {
        message,
        defaultMessage: "Expected function to throw",
        hideDiff: true,
      });
    } else {
      const msg = typeof errorOrMessage !== "undefined" ? errorOrMessage : message;
      (0, exports.processAssert)(() => nodeAssert.throws(block, message), {
        message: msg,
        defaultMessage: "Expected function to throw",
        hideDiff: true,
      });
    }
  }
  async function rejects(block, errorOrMessage, message) {
    await (0, exports.processAssert)(
      async () => {
        if (
          typeof errorOrMessage === "function" ||
          errorOrMessage instanceof RegExp ||
          typeof errorOrMessage === "object"
        ) {
          await nodeAssert.rejects(block, errorOrMessage, message);
        } else {
          const msg = typeof errorOrMessage === "string" ? errorOrMessage : message;
          await nodeAssert.rejects(block, msg);
        }
      },
      {
        message: typeof errorOrMessage === "string" ? errorOrMessage : message,
        defaultMessage: "Expected promise to be rejected with specified error",
        hideDiff: true,
        throw: true,
      }
    );
  }
  async function doesNotReject(block, errorOrMessage, message) {
    await (0, exports.processAssert)(
      async () => {
        if (
          typeof errorOrMessage === "function" ||
          errorOrMessage instanceof RegExp ||
          typeof errorOrMessage === "object"
        ) {
          await nodeAssert.doesNotReject(block, errorOrMessage, message);
        } else {
          await nodeAssert.doesNotReject(block, message);
        }
      },
      {
        message: typeof errorOrMessage === "string" ? errorOrMessage : message,
        defaultMessage: "Got unwanted rejection",
        hideDiff: true,
        throw: true,
      }
    );
  }
  const match = (value, regExp, message) => {
    if (typeof get_runtime_js_1.nodeVersion === "number" && get_runtime_js_1.nodeVersion < 12) {
      throw new Error("match is available from Node.js 12 or higher");
    }
    (0, exports.processAssert)(
      () => (nodeAssert === null || nodeAssert === void 0 ? void 0 : nodeAssert.match(value, regExp)),
      {
        message,
        actual: "Value",
        expected: "RegExp",
        defaultMessage: "Value should match regExp",
      }
    );
  };
  const doesNotMatch = (value, regExp, message) => {
    if (typeof get_runtime_js_1.nodeVersion === "number" && get_runtime_js_1.nodeVersion < 12) {
      throw new Error("doesNotMatch is available from Node.js 12 or higher");
    }
    (0, exports.processAssert)(() => nodeAssert.doesNotMatch(value, regExp), {
      message,
      actual: "Value",
      expected: "RegExp",
      defaultMessage: "Value should not match regExp",
    });
  };
  const assert = Object.assign((value, message) => ok(value, message), {
    ok,
    equal,
    deepEqual,
    strictEqual,
    deepStrictEqual,
    doesNotMatch,
    doesNotReject,
    throws,
    doesNotThrow,
    notEqual,
    notDeepEqual,
    notStrictEqual,
    notDeepStrictEqual,
    match,
    ifError,
    fail,
    rejects,
  });
  return assert;
};
exports.createAssert = createAssert;
